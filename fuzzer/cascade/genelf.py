# Copyright 2023 Flavien Solt, ETH Zurich.
# Licensed under the General Public License, Version 3.0, see LICENSE for details.
# SPDX-License-Identifier: GPL-3.0-only

# This module generates ELF files from a program generated by Cascade.

from params.runparams import DO_ASSERT, PATH_TO_TMP
from common.bytestoelf import gen_elf
from cascade.finalblock import finalblock_spike_resolution
from common import nbf

from collections import defaultdict
import os
import subprocess
import sys

# From a fuzzerstate, generates an ELF, may it be for spike resolution or for RTL simulation
# Also integrates the final block.
# @param instr_objs an iterable (one per basic block) of iterables of CFInstructions or placeholders
# @param test_identifier typically the random seed, mem size, design name, max number of bbs
# @return the generated elf path
def gen_elf_from_bbs(fuzzerstate, is_spike_resolution, prefixname: str, test_identifier: str, start_addr: int):
    if DO_ASSERT:
        assert len(fuzzerstate.instr_objs_seq) == len(fuzzerstate.bb_start_addr_seq)

    # Create the bytecode for the ELF file
    addr_instrs = defaultdict(bytes) # addr_instrs[addr] = single byte
    for bb_start_addr, bb_instrs in zip(fuzzerstate.bb_start_addr_seq, fuzzerstate.instr_objs_seq):
        for instr_id_in_bb, instr_obj in enumerate(bb_instrs):
            curr_bytecode = instr_obj.gen_bytecode_int(is_spike_resolution=is_spike_resolution).to_bytes(4, 'little')
            for curr_byte_id, curr_byte in enumerate(curr_bytecode):
                curr_addr = bb_start_addr + 4*instr_id_in_bb + curr_byte_id # NO_COMPRESSED
                if DO_ASSERT:
                    assert curr_addr not in addr_instrs, f"Trying to write twice to the same address: {hex(curr_addr)}"
                addr_instrs[curr_addr] = curr_byte

    for instr_id_in_bb, instr_obj in enumerate(fuzzerstate.ctxsv_bb):
        if instr_obj is None:
            raise ValueError(f"instrobj is None for ctxsv_bb at index {instr_id_in_bb}")
        curr_bytecode = instr_obj.gen_bytecode_int(is_spike_resolution=is_spike_resolution).to_bytes(4, 'little')
        for curr_byte_id, curr_byte in enumerate(curr_bytecode):
            curr_addr = fuzzerstate.ctxsv_bb_base_addr + 4*instr_id_in_bb + curr_byte_id # NO_COMPRESSED
            if DO_ASSERT:
                assert curr_addr not in addr_instrs, f"Trying to write twice to the same address: {hex(curr_addr)}"
            addr_instrs[curr_addr] = curr_byte

    # Add the initial register values
    for reg_data_id, reg_data_doubleword in enumerate(fuzzerstate.initial_reg_data_content):
        curr_bytecode = reg_data_doubleword.to_bytes(8, 'little')
        for curr_byte_id, curr_byte in enumerate(curr_bytecode):
            curr_addr = fuzzerstate.initial_reg_data_addr + 8*reg_data_id + curr_byte_id # doublewords therefore 8
            if DO_ASSERT:
                assert curr_addr not in addr_instrs, f"Trying to write twice to the same address: {hex(curr_addr)}"
            addr_instrs[curr_addr] = curr_byte

    # Add the final basic block
    if is_spike_resolution:
        final_block = finalblock_spike_resolution()
    else:
        final_block = fuzzerstate.final_bb
    for instr_id_in_bb, instr_obj in enumerate(final_block):
        curr_bytecode = instr_obj.gen_bytecode_int(is_spike_resolution=is_spike_resolution).to_bytes(4, 'little')
        for curr_byte_id, curr_byte in enumerate(curr_bytecode):
            curr_addr = fuzzerstate.final_bb_base_addr + 4*instr_id_in_bb + curr_byte_id # NO_COMPRESSED
            if DO_ASSERT:
                assert curr_addr not in addr_instrs, f"Trying to write twice to the same address: {hex(curr_addr)}"
            addr_instrs[curr_addr] = curr_byte

    # Add the random data block
    for word_id, word_content in enumerate(fuzzerstate.random_block_content4by4bytes):
        curr_bytecode = word_content.to_bytes(4, 'little')
        for curr_byte_id, curr_byte in enumerate(curr_bytecode):
            curr_addr = fuzzerstate.random_data_block_start_addr + 4*word_id + curr_byte_id # NO_COMPRESSED
            if DO_ASSERT:
                assert curr_addr not in addr_instrs, f"Trying to write twice to the same address: {hex(curr_addr)}"
            addr_instrs[curr_addr] = curr_byte

    # Generate a bytes object
    curr_bytearray = bytearray(fuzzerstate.memsize) # Zero-filled
    for curr_addr, curr_byte in addr_instrs.items():
        curr_bytearray[curr_addr] = curr_byte
    curr_bytes = bytes(curr_bytearray)

    elfpath = os.path.join(PATH_TO_TMP, f"{prefixname}{test_identifier}.elf")
    # Generate the ELF object
    gen_elf(curr_bytes, start_addr=fuzzerstate.bb_start_addr_seq[0], section_addr=start_addr, destination_path=elfpath, is_64bit=fuzzerstate.is_design_64bit)

    #print (elfpath)
    mem_file = elfpath[:-4] + '.mem'
    nbf_file = elfpath[:-4] + '.nbf'
    riscv_file = elfpath[:-4] + '.riscv'
    f = open(nbf_file, 'w') 
    # Convert to NBF for BP
    if fuzzerstate.design_name == 'bp':
        if subprocess.run(['/home/mysanoop/zynq-farm/latest/zynq-parrot/software/import/black-parrot-sdk/install/bin/riscv64-unknown-elf-dramfs-objcopy', '-O', 'verilog', elfpath, mem_file]):
            converter = nbf.NBF(1, '', mem_file, 16, '', True, True, 40, 64, '0x80000000', False, False)
            orig_stdout = sys.stdout
            sys.stdout = f
            converter.dump()
            sys.stdout = orig_stdout
        else:
            assert False, 'Did not generate NBF path'

    gen_elf(curr_bytes, start_addr=fuzzerstate.bb_start_addr_seq[0], section_addr=0x8000_0000, destination_path=elfpath[:-4] + '.riscv', is_64bit=fuzzerstate.is_design_64bit)

    return elfpath, nbf_file if fuzzerstate.design_name == 'bp' else 'dummy', riscv_file if fuzzerstate.design_name == 'bp' else 'dummy'
